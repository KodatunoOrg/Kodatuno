<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> 
<HTML> 
<HEAD LANG="ja"> 
	<TITLE>Kodatuno User's Guide</TITLE> 
	<meta HTTP-EQUIV="Content-type" CONTENT="text/html; charset=euc-jp"> 
</HEAD> 
<BODY bgcolor="#ffffff"> 
<table cellspacing="0" cellpadding="0" border="0" width="100%">   
	<tr valign="top" height="32">   
	</tr>   
	<tr valign="top">        
		<td width="256" valign="bottom" align="left">          
			<IMG SRC="pixmaps/logo.jpg" width="300" height="98" alt="Kodatuno Logo" ALIGN="top">
		</td>        
		<td valign="bottom" align="center">          
			<center> 	   
		<b><big>Kodatuno User's Guide</big>
		</b>
		<center>        
		</td>       
		<td width="20%" valign="bottom" align="right">     
			<A HREF="./2-7.html">Prev</A>     
			<A HREF="./index.html">Index</A>
			<A HREF="./2-9.html">Next</A><br>
		</td>   
	</tr> 
</table> 
<blockquote> 

<BR><HR><H2>BODYListとOBJECTList</H2>

画面上で選択された曲線/曲面の幾何情報はBODYListとOBJECTListの2つに格納され、UserFuncとへ渡されます。<BR>
このセクションでは、これら2つのリストについて説明します。<BR><BR>

BODYListとOBJECTListはBODY.h内で次のように定義されています。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/typedef_bodylist_objectlist.jpg"></CENTER></P></CENTER></P>
更にKODlistDataはKodListFunc.h内で定義されており、リストを操作するいくつかの関数を持ったクラスです。
つまりBODYListとOBJECTListはKODlistDataクラスの別名であり、元々は同じものを指します。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/KODListData_Class.jpg"></CENTER></P></CENTER></P>
次に、このKODlistDataクラスに格納されるデータの実体を見てみると、Data型として宣言されており、更にこのData型は
自己参照クラスとして定義されています。このDataクラス内で宣言されている変数void *dataに、セレクションされたデータの実体(幾何情報やセレクション情報)
が格納されます。void *型として定義しているため、実際に格納するデータはどんなものでも構わず、(void *)型にキャストして格納します。
つまり、KODlistDataクラスはリスト構造を構築するための箱という役割となっています。<BR><BR>

これをふまえて、<A HREF="2-6.html">2.6  サンプルアプリケーションのソース解説 </A>で示したExecSampleFunc1()関数をもう一度以下に示します。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/UserFunc_ExecSampleFunc1.jpg"></CENTER></P></CENTER></P>
19行目及び20行目において、セレクションされたデータの実体をKODlistDataからそれぞれ取り出しています。
データの取り出しには、KODlistDataクラスで定義されているgetData()関数を使います。このとき、その関数の頭には(OBJECT *)や(BODY *)
が付いており、void *dataをOBJECT構造体やBODY構造体にキャストしていることが分かります。<BR>
BODY構造体については<A HREF="3-8.html">3.8  CADデータの内部表現 </A>を参照してください。<BR>
では次に、OBJECT構造体を見てみます。OBJECT構造体はBODY.ｈに定義されています。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/OBJECT_Structure.jpg"></CENTER></P></CENTER></P>
OBJECT構造体には、セレクションされたエンティティがどのBODYに属しているか、面なのか線なのか、エンティティに割り振られたIDなど、
セレクションされたエンティティを特定するための情報が格納されています。よってExecSampleFunc1()の19行目の様に、例えば<BR><BR>
　　　OBJECT *obj = (OBJCET *)ObjList->getData(i);<BR><BR>
とすれば、i番目にセレクションされたエンティティを特定するための情報がobjに格納さることになります。
この特定情報objを元に実際にBODYの実体を引っ張ってくるには、20行目、<BR><BR>
　　　BODY *body = (BODY *)BodyList->getData(obj->Body);<BR><BR>
となります。getData()で引っ張ってくるデータのIDがobjの要素Bodyに格納されているわけです。<BR>
次に23行目を見てみると、obj->Typeの中身を見て条件分岐していることが分かります。セレクションされたエンティティがNURBS曲面(#128)なのかNURBS曲線(#126)なのかといった
形状情報がここに格納されます。エンティティに割り振られた番号はBODH.h内に定義されています。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/Entity_Symbol.jpg"></CENTER></P></CENTER></P>
ただし、Kodatunoでは全てがNURBS表現が基本ですので、obj->Typeには#126、#128、#144しか今のところ格納されません。<BR>
セレクションされたエンティティの幾何情報を実際に参照するには、24行目の<BR><BR>
　　　body->NurbsS[obj->Num]<BR><BR>
のように、obj->NumがセレクションされたエンティティにおけるTypeごとのIDとなり、20行目で取得したBodyの実体から辿ることができます。<BR>


最後に、セレクションとOBJECT構造体との関係を模式的に表した図を示します。
<P><CENTER><P><CENTER><IMG SRC="pixmaps/Selection_architecture.jpg"></CENTER></P></CENTER></P>

</blockquote> <HR> Document Release 2.0 for Kodatuno R2.0, Nov. 2011<P> <hr> <center>
<A HREF="./2-7.html">Prev</A>
<A HREF="./index.html">index</A>
<A HREF="./2-9.html">Next</A><br>
</center> <hr> <table cellpadding="0" cellspacing="0" border="0" width="100%">    
<tr>      
	<td align="left">        
		<small>Copyright(C) Kodatuno Development Team, 2011</small>      
	</td>      
	<td align="right">        
		<small><i>Last modified: Nov. 11, 2011</i></small>      
	</td>   
</tr> </table>  <!-- end of body --> </body>  
</html>  

